---
title: "dialysistrackR"
output:
  pdf_document:
    latex_engine: xelatex
    keep_tex: true
    includes:
      in_header: sansfont.tex ##check out the writelines command in scratch if not working, run that first mate
  html_document: default
date: "`r Sys.Date()`"
---



## Introduction

This report was generated using a collaborative R Markdown workflow designed to support transparent, reproducible analysis across sites. The project is maintained in a shared GitHub repository, with version tracking, package management, and rendering controlled programmatically to ensure consistency across contributors and outputs. 

The content that follows represents the current state of shared analysis, with outputs suitable for team review, audit and integration into clinical workflows.

```{r dataload, include=FALSE, warning=FALSE, message=FALSE}
## Dependencies ---- 
# TinyTeX (Latex renderer)
#library(readr)
library(tidyverse)
#library(lubridate)
library(knitr)
library(kableExtra)
library(tinytex)
#library(dplyr)
#library(tidyr)

library(scales)  # for percent formatting

library(glue)


### function update - for the smushed x axis

scatterplotTheme <- theme_minimal() +
  theme(
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    axis.title.y = element_text(angle = 90, vjust = 0.5),
    axis.title.x = element_text(vjust = -1),
    axis.text.x = element_text(angle = 45, hjust = 1)  # Rotate x-axis labels
  )




### Data cleaning ----

# There may be changes to data format as Nick refines his workflow, but some of the principles will remain the same and this data cleaning section we can update until the pipeline stabilises



#read in data ----
coreData <- read_csv("DUMMY_DAT.csv", na = c("", " ", "NA")) ## nice use of readr btw


coreData <- coreData %>%
  mutate(
    Collected = dmy_hm(Collected),         # Parse as date-time (day-month-year hour:minute)
    CollectedDate = as.Date(Collected)     # Keep just the date part - we can use this bit for graphs later.
  )

### DUMMY_DAT structure
# pt URN              | Hb_col | K_col | ...
# New URN for each pt | Hb_val | K_val | ...


### Global Vars

## flag outputs
coreData <- coreData %>%
  mutate(
    HGB_flag = case_when(
      HGB < 80 ~ "Low",
      HGB > 120 ~ "High",
      !is.na(HGB) ~ "Target",
      TRUE ~ NA_character_
    ),
    ALB_flag = case_when(
      ALB < 35 ~ "Low",
      ALB >= 35 & ALB <= 50 ~ "Target",
      ALB > 50 ~ "High",
      TRUE ~ NA_character_
    ),
    PHOS_flag = case_when(
      PHOS < 1.1 ~ "Low",
      PHOS > 1.8 ~ "High",
      !is.na(PHOS) ~ "Target",
      TRUE ~ NA_character_
    ),
    PTHR_flag = case_when(
      PTHR < 15 ~ "Low",
      PTHR > 90 ~ "High",
      !is.na(PTHR) ~ "Target",
      TRUE ~ NA_character_
    ),
    TRFSAT_flag = case_when(
      TRFSAT < 20 ~ "Low",
      TRFSAT > 50 ~ "High",
      !is.na(TRFSAT) ~ "Target",
      TRUE ~ NA_character_
    )
  )

### DUMMY DATA GENERATION
# Create synthetic patient IDs
n_patients <- 500
existing_urs <- paste0("RB", sprintf("%06d", sample(100000:999999, n_patients)))

# Define normal lab means and SDs
lab_means <- list(
  HGB = 110, TRFSAT = 30, K = 4.5, PTHR = 50, PHOS = 1.6, CAL = 2.3, ALB = 38
)
lab_sds <- list(
  HGB = 8, TRFSAT = 5, K = 0.3, PTHR = 10, PHOS = 0.2, CAL = 0.1, ALB = 3
)

# Drift assignment for ~15% of patients
n_drift <- round(0.15 * n_patients)
drift_map <- rep("normal", n_patients) #default all pts drift = normal
drift_map[sample(1:n_patients, n_drift / 2)] <- "low" #random sample assign low drift (half of 15%)
drift_map[sample(
  setdiff(1:n_patients, which(drift_map == "low")  # take difference between whole set and subset of pts assigned low
          ), n_drift / 2)] <- "high" # random sample assign high drift to pts of above subset
names(drift_map) <- existing_urs 
# drift map structure
# vector of values, with URN name assignments

# Synthetic longitudinal data generator
generate_longitudinal <- function(ur_number, drift_type = "normal") {
  drift <- switch(drift_type, 
                  "low" = -1, 
                  "high" = +1, 
                  "normal" = 0) 
  #switch statement assigns drift group to specific value
  
  # Set the start date so the final (12th) sample lands near today
  start_date <- Sys.Date() %m-% months(11)
  # take each URN + drift val
  # random sample generate a lab val for each of the below categories. 
  # using already assigned lab-val mean + add drift
  # repeat for each month

  tibble(
    `Ur Number` = ur_number,
    Collected = start_date + 
      months(0:11) + 
      days(sample(-15:15, 12, replace = TRUE)) + 
      hours(sample(6:16, 12, replace = TRUE)),
    HGB    = round(rnorm(12, lab_means$HGB + drift * 15, lab_sds$HGB), 1),
    TRFSAT = round(rnorm(12, lab_means$TRFSAT + drift * 10, lab_sds$TRFSAT), 1),
    K      = round(rnorm(12, lab_means$K + drift * 0.8, lab_sds$K), 2),
    PTHR   = round(rnorm(12, lab_means$PTHR + drift * 30, lab_sds$PTHR)),
    PHOS   = round(rnorm(12, lab_means$PHOS + drift * 0.5, lab_sds$PHOS), 2),
    CAL    = round(rnorm(12, lab_means$CAL + drift * 0.15, lab_sds$CAL), 2),
    ALB    = round(rnorm(12, lab_means$ALB + drift * 4, lab_sds$ALB), 1),
    HBSAB  = sample(c(">1000", "10-1000", "<10"), 12, replace = TRUE, prob = c(0.7, 0.25, 0.05))
  )
}

# Generate full dataset
coreData <- bind_rows(lapply(existing_urs, function(ur) {
  generate_longitudinal(ur_number = ur, drift_type = drift_map[[ur]])
})) %>%
  mutate(
    Collected = as.POSIXct(Collected),
    CollectedDate = as.Date(Collected)
  )

```

```{r plot_generator, echo=FALSE, warning=FALSE, message=FALSE}

## PLOT GENERATOR FUNCTION
## now a summary table

plot_lab_trend <- function(df, lab_var, date_range, y_label = NULL, y_limits = NULL) {
  lab_var <- rlang::ensym(lab_var)

  # Calculate weekly median
  weekly_summary <- df %>%
    mutate(WeekStart = lubridate::floor_date(CollectedDate, unit = "week", week_start = 1)) %>%
    group_by(WeekStart) %>%
    summarise(median_value = median(!!lab_var, na.rm = TRUE), .groups = "drop")

  # Build plot
  ggplot(df %>% filter(CollectedDate > date_range[1], CollectedDate < date_range[2]), 
         aes(x = CollectedDate, y = !!lab_var)) +
    geom_point(
      position = position_jitter(width = 5, height = 0),
      alpha = 0.25, size = 1.5, color = "grey40"
    ) +
    geom_smooth(method = "loess", span = 0.25, se = TRUE,
                color = "firebrick", fill = "firebrick", alpha = 0.2) +
    geom_line(
      data = weekly_summary %>% filter(WeekStart > date_range[1], WeekStart < date_range[2]), 
      aes(x = WeekStart, y = median_value),
      inherit.aes = FALSE, color = "steelblue", linewidth = 1.2
    ) +
    geom_point(
      data = weekly_summary %>% filter(WeekStart > date_range[1], WeekStart < date_range[2]), 
      aes(x = WeekStart, y = median_value),
      inherit.aes = FALSE, color = "steelblue", size = 2
    ) +
    {if (!is.null(y_limits)) geom_hline(yintercept = y_limits, color = "red", linetype = "dashed")} +
    scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
    labs(
      title = paste0(rlang::as_label(lab_var), " Over Time"),
      x = "Date", y = y_label %||% rlang::as_label(lab_var)
    ) +
    theme_minimal() +
    theme(
      panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(),
      axis.title.y = element_text(angle = 90, vjust = 0.5),
      axis.title.x = element_text(vjust = -1),
      axis.text.x = element_text(angle = 45, hjust = 1)
    )
}
```

# Haemoglobin
## Interpretation

This plot visualises haemoglobin (HGB) levels across the unit over time. Unit-level trends can help identify systemic issues affecting multiple patients — such as inconsistent access to erythropoiesis-stimulating agents (ESAs), delays in blood draws, or problems with iron management.

-   Raw data (grey dots): Each point represents a single HGB result from an individual patient on a specific date, imported directly from AUSLAB.

-   Red line (LOESS curve): A smoothed estimate of the trend in HGB values over time. LOESS (Locally Estimated Scatterplot Smoothing) is a nonparametric method that fits multiple small, local regressions to the data. It’s particularly useful for visualising subtle shifts and inflection points without assuming a linear or fixed relationship.

-   Pale red area (confidence interval): A 95% confidence interval around the LOESS curve. It gives a visual indication of uncertainty in the smoothed trend — wider areas imply more variability or fewer observations at that timepoint.

-   Blue line (weekly median): The weekly median HGB, calculated across all patients tested in that week. It provides a robust, point-in-time summary less sensitive to extreme values than the mean.

-   Red dashed lines: The Kidney Health Service’s target haemoglobin range (80–120 g/L). Values falling persistently outside this band may indicate a need for clinical review at the unit or system level.

##

```{r plot_function_trend_tables, echo=FALSE, warning=FALSE, message=FALSE}

#Add flag + trend 
coreData_with_trend <- coreData %>%
  arrange(`Ur Number`, Collected) %>%
  group_by(`Ur Number`) %>%
  mutate(
    previous_HGB = lag(HGB),
    HGB_flag = case_when(
      HGB < 100 ~ "Low",
      HGB > 160 ~ "High",
      TRUE ~ "Target"
    ),
    HGB_trend = case_when(
      is.na(previous_HGB) | is.na(HGB) ~ NA_character_,
      HGB - previous_HGB > 10 ~ "↑ Rising",
      HGB - previous_HGB < -10 ~ "↓ Falling"
    )
  ) %>%
  ungroup()

# HGB outside threshold
table_date_range <- c(as.Date("2024-08-01"), as.Date("2024-10-01")) # show results within specific data range
coreData_with_trend[coreData_with_trend$CollectedDate>table_date_range[1] &
                    coreData_with_trend$CollectedDate<table_date_range[2], ] %>%
  group_by(`Ur Number`) %>%
  filter(Collected == max(Collected, na.rm = TRUE)) %>%  # ← Get most recent row per patient
  ungroup() %>%
  filter(HGB_flag %in% c("High", "Low")) %>%
  select(`Ur Number`, Collected, HGB, HGB_flag, HGB_trend) %>% # remove Hgb_flag from table once finished debugging?
  arrange(HGB, `Ur Number`, Collected) %>% #prioritise by lowest Hb first
  mutate(Collected = format(Collected, "%d-%b-%Y")) %>%
  kbl(
    caption = paste("Hb results out of range between:", table_date_range[1], "and", table_date_range[2]),
    col.names = c("Patient UR", "Date", "HGB (g/L)", "Flag", "Trend"),
    booktabs = TRUE,
    align = "lcccl"
  ) %>%
  kable_styling(latex_options = c("striped", "hold_position"))%>%
  add_footnote(
    label = "Trend indicates a change of 10 units as compared to prior result, regardless of date. Only patients with High or Low results are shown.",
    notation = "none"
  )

## this is much easier to work with I think going forwards
# Calculate last 6 months range from today's date
plot_lab_trend(
  coreData,
  HGB,
  date_range = c(Sys.Date() %m-% months(6), Sys.Date()),
  y_label = "HGB (g/L)",
  y_limits = c(80, 120)
)


```

```{r trend_sorting_and_highlighting, echo=FALSE, warning=FALSE, message=FALSE}

# UNIT by UNIT analysis
# Subset 50 patients and last 6 months of data
set.seed(42)
subset_ids <- sample(unique(coreData_with_trend$`Ur Number`), 50)
latest_date <- max(coreData_with_trend$CollectedDate, na.rm = TRUE)

subset_data <- coreData_with_trend %>%
  filter(
    `Ur Number` %in% subset_ids,
    CollectedDate >= latest_date %m-% months(6)
  )

# Trend summary on last sample per patient
trend_summary <- coreData_with_trend %>%
  filter(`Ur Number` %in% subset_ids) %>%
  group_by(`Ur Number`) %>%
  filter(CollectedDate == max(CollectedDate, na.rm = TRUE)) %>%
  ungroup() %>%
  count(HGB_trend) %>%
  complete(HGB_trend = c("↓ Falling", "↑ Rising", "→ Stable"), fill = list(n = 0)) %>%
  mutate(p = n / sum(n))

## HIGHLIGHT STATUS for graphs
subset_data <- subset_data %>%
  mutate(
    highlight_status = case_when(
      HGB_trend == "↑ Rising" & (HGB > 120) ~ "Rising & outside range",
      HGB_trend == "↑ Rising"                           ~ "Rising & within range",
      HGB_trend == "↓ Falling" & (HGB < 80) ~ "Falling & outside range",
      HGB_trend == "↓ Falling"                          ~ "Falling & within range",
      HGB_trend == "→ Stable"                           ~ "Stable",
      TRUE                                              ~ "Other"
    )
  )

coreData_with_trend <- coreData_with_trend %>%
  mutate(
    highlight_status = case_when(
      HGB_trend == "↑ Rising" & (HGB > 120) ~ "Rising & outside range",
      HGB_trend == "↑ Rising"                           ~ "Rising & within range",
      HGB_trend == "↓ Falling" & (HGB < 80) ~ "Falling & outside range",
      HGB_trend == "↓ Falling"                          ~ "Falling & within range",
      HGB_trend == "→ Stable"                           ~ "Stable",
      TRUE                                              ~ "Other"
    )
  )

# Colour palette
custom_colors <- c(
  "Rising & outside range" = "#1ab31d",     # dark green
  "Rising & within range"  = "#295225",     # light green
  "Falling & outside range" = "#ff1515",    # dark red
  "Falling & within range"  = "#5e2020",    # light coral
  "Stable within range" = "grey60"
)
# Dynamic subtitle with n and proportions
subtitle_text <- paste0(
  "Coloured by trend on most recent test ",
  percent(trend_summary$p[trend_summary$HGB_trend == "↓ Falling"], accuracy = 1), " falling, ",
  percent(trend_summary$p[trend_summary$HGB_trend == "↑ Rising"], accuracy = 1), " rising "
)


# Summarize each patient by most recent result
subset_table <- subset_data %>%
  group_by(`Ur Number`) %>%
  filter(CollectedDate == max(CollectedDate, na.rm = TRUE)) %>%
  ungroup() %>%
  select(`Ur Number`, CollectedDate, HGB, HGB_trend, highlight_status) %>%
  arrange(desc(CollectedDate)) %>%
  mutate(CollectedDate = format(CollectedDate, "%d-%b-%Y"))


# Take only the most recent results for each pt for latest trends
latest_trends <- subset_data %>%
  group_by(`Ur Number`) %>%
  filter(CollectedDate == max(CollectedDate, na.rm = TRUE)) %>%
  ungroup()

# Compute percentages for falling, rising, stable
trend_counts <- latest_trends %>%
  mutate(trend_category = case_when(
    grepl("Falling", highlight_status) ~ "Falling",
    grepl("Rising", highlight_status) ~ "Rising",
    grepl("Stable", highlight_status) ~ "Stable",
    TRUE ~ "Other"
  )) %>%
  count(trend_category) %>%
  mutate(p = n / sum(n)) %>%
  complete(trend_category = c("Falling", "Rising", "Stable"), fill = list(n = 0, p = 0))
```


```{r Individual_patients, echo=FALSE, warning=FALSE, message=FALSE}
# ALL Pt data
# TODO: Stable points = grey + reduced transparency
ggplot(coreData_with_trend, aes(x = CollectedDate, y = HGB, group = `Ur Number`)) +
  
  # Background points (stable, forgettem)
#  geom_line(data = coreData_with_trend %>% filter(HGB_trend == "→ Stable"),
#            aes(group = `Ur Number`), color = "grey80", alpha = 0.4, linewidth = 0.6) +
 # geom_point(data = coreData_with_trend %>% filter(HGB_trend == "→ Stable"),
 #            color = "grey70", size = 1.2, alpha = 0.3,
 #            position = position_jitter(width = 3, height = 0)) +
  
  # Foreground lines (rising/falling)
  #geom_line(data = coreData_with_trend %>% filter(HGB_trend %in% c("↑ Rising", "↓ Falling")),
  #          aes(color = HGB_trend), linewidth = 0.8, alpha = 0.4) +
 # geom_line(data = coreData_with_trend, aes(color = append(embed(highlight_status,2)[,1],"Other")), linewidth = 0.7, alpha = 0.6) + #Added embed function - sets individual pt graphs to correct segment colouring
  geom_point(data = coreData_with_trend %>% filter(HGB_trend %in% c("↑ Rising", "↓ Falling")),
             aes(color = highlight_status), size = 0.2,
             position = position_jitter(width = 3, height = 0)) +

  geom_hline(yintercept = c(80, 120), linetype = "dashed", color = "grey60") +

  scale_color_manual(
    values = c("↑ Rising" = "forestgreen", "↓ Falling" = "firebrick")
  ) +
  scale_color_manual(values = custom_colors) +
  # Monthly x-axis
  scale_x_date(date_breaks = "1 month", date_labels = "%b %Y", expand = c(0.01, 0.01)) +

  labs(
    title = "Haemoglobin Trends by Patient",
    subtitle = paste0("Last test trends: ",
                      percent(trend_summary$p[trend_summary$HGB_trend == "↓ Falling"], accuracy = 1),
                      " falling, ",
                      percent(trend_summary$p[trend_summary$HGB_trend == "↑ Rising"], accuracy = 1),
                      " rising"),
    x = "Date",
    y = "HGB (g/L)",
    color = "Trend"
  ) +

  theme_minimal() +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1)
  )
```

``` {r plot_by_unit, echo=FALSE, warning=FALSE, message=FALSE}

# Display as nice PDF/HTML table
kbl(
  subset_table,
  caption = "Summary of Most Recent Haemoglobin Results for Subset Patients",
  col.names = c("Patient UR", "Date", "HGB (g/L)", "Trend", "Trend + Range"),
  booktabs = TRUE,
  align = "lcccl"
) %>%
  kable_styling(latex_options = c("striped", "hold_position"))

### PLOT: trends
ggplot(subset_data, aes(x = CollectedDate, y = HGB, group = `Ur Number`)) +
  # Target band
  geom_rect(
    aes(
      xmin = min(CollectedDate, na.rm = TRUE),
      xmax = max(CollectedDate, na.rm = TRUE),
      ymin = 80, ymax = 120
    ),
    fill = "grey90", alpha = 0.2, inherit.aes = FALSE
  ) +

  # Dashed threshold lines
  geom_hline(yintercept = c(80, 120), linetype = "dashed", color = "grey60") +

  # Lines for all trends (stable lines in grey)
  geom_line(aes(color = append(embed(highlight_status,2)[,1],"Other")), linewidth = 0.7, alpha = 0.6) + #Added embed function - sets individual pt graphs to correct segment colouring
  geom_point(aes(color = highlight_status), size = 1.6, alpha = 0.9, 
             position = position_jitter(width = 3, height = 0)) +

  scale_color_manual(values = custom_colors) +

  scale_x_date(date_breaks = "1 month", date_labels = "%b %Y", expand = c(0.01, 0.01)) +

  labs(
    title = "Haemoglobin Trends (Northlakes, Last 6 Months)",
    subtitle = subtitle_text,
    x = "Date",
    y = "HGB (g/L)",
    color = "Trend + Range"
  ) +

  theme_minimal() +
  theme(
    legend.position = "bottom",
    axis.text.x = element_text(angle = 45, hjust = 1))

```
### Patient level Hb interpretation
``` {r plot_by_unit_interpretations,  echo=FALSE, warning=FALSE, message=FALSE}

#SUPERGROUP Interpretation
# Extract percentages
falling_pct <- percent(trend_summary$p[trend_summary$HGB_trend == "↓ Falling"], accuracy = 1)
rising_pct  <- percent(trend_summary$p[trend_summary$HGB_trend == "↑ Rising"], accuracy = 1)
stable_pct  <- percent(trend_summary$p[trend_summary$HGB_trend == "→ Stable"], accuracy = 1)

# Compose interpretation

interpretation_text <- glue(
  "This plot displays haemoglobin (HGB) levels over time for individual patients, each represented by a connected line. ",
  "Colours reflect the direction of change based on their most recent result:\n",
  "- Red indicates a downward trend (↓ Falling)\n",
  "- Green indicates an upward trend (↑ Rising)\n\n",
  "The dashed grey lines represent target HGB thresholds (80–120 g/L). The background band highlights the target range. ",
  "Most patients remain within or near target, but as of the most recent test: {falling_pct} show a falling trend, ",
  "{rising_pct} show a rising trend, and {stable_pct} are stable.\n\n")

# SUBGROUP Interpretation
# Extract percentages
falling_pct_subgroup <- percent(trend_counts$p[trend_counts$trend_category == "Falling"], accuracy = 1)
rising_pct_subgroup  <- percent(trend_counts$p[trend_counts$trend_category == "Rising"], accuracy = 1)
stable_pct_subgroup  <- percent(trend_counts$p[trend_counts$trend_category == "Stable"], accuracy = 1)

interpretation_text_subgroup <- glue(
  "This figure shows longitudinal haemoglobin (HGB) results for 50 patients at the Northlakes unit over the past six months. ",
  "Each line represents an individual patient trajectory, coloured by both the direction of trend and whether the most recent result was within the target range.\n\n",
  "- Green: Rising HGB\n",
  "- Red: Falling HGB\n",
  "- Grey: Stable HGB\n",
  "- Brighter colours indicate a most recent value outside the 80–120 g/L target range; muted colours indicate values within range.\n\n",
  "As of the most recent measurement:\n",
  "- {falling_pct_subgroup} of patients were trending downward\n",
  "- {rising_pct_subgroup} were trending upward\n",
  "- {stable_pct_subgroup} were stable\n\n",
  "The shaded region indicates the HGB target range (80–120 g/L). This visual supports identification of patients who may benefit from anaemia review or intervention."
)


```
`r interpretation_text`
`r interpretation_text_subgroup`

### Haemoglobin Results tabulated

```{r hgb_analysis, echo=FALSE, warning=FALSE, message=FALSE}


# Define HGB targets
lower_limit <- 80
upper_limit <- 120

# Filter to most recent result per patient
latest_hgb <- coreData %>%
  filter(!is.na(HGB)) %>%
  arrange(`Ur Number`, desc(CollectedDate)) %>%
  group_by(`Ur Number`) %>%
  slice_head(n = 1) %>%
  ungroup()

# Categorise based on target range
total_patients <- n_distinct(latest_hgb$`Ur Number`)

hgb_stats <- latest_hgb %>%
  mutate(HGB_category = case_when(
    HGB < lower_limit ~ "Below Target",
    HGB > upper_limit ~ "Above Target",
    TRUE ~ "Within Target"
  )) %>%
  group_by(HGB_category) %>%
  summarise(
    n_patients = n(),
    prop_patients = round(100 * n_patients / total_patients, 1),
    .groups = "drop"
  )

# Print clean summary
hgb_stats %>%
  mutate(
    line = sprintf(
      "%-15s | %3d patients | %5.1f%%",
      HGB_category, n_patients, prop_patients
    )
  ) %>%
  pull(line) %>%
  cat(sep = "\n")

coreData <- coreData %>%
  mutate(CollectedDate = as.Date(Collected))

# Define HGB flags: drop below target and acute drop
coreData <- coreData %>%
  arrange(`Ur Number`, CollectedDate) %>%
  group_by(`Ur Number`) %>%
  mutate(
    prev_HGB = lag(HGB),
    prev_date = lag(CollectedDate),
    delta_HGB = HGB - prev_HGB,
    delta_days = as.numeric(CollectedDate - prev_date),
    dHb_over_dDays = delta_HGB/delta_days #Hb drop per day, faster daily drops =? bigger priority
  ) %>%
  ungroup()

# 1. Drop from ≥80 to <80
drop_below_target <- coreData %>%
  filter(!is.na(HGB) & !is.na(prev_HGB) & prev_HGB >= 80 & HGB < 80) %>%
  mutate(Event = "Drop from ≥80 to <80 g/L")

# 2. Drop ≥10 g/L in ≤30 days
drop_10_in_1_month <- coreData %>%
  filter(!is.na(delta_HGB) & delta_HGB <= -10 & delta_days <= 30) %>%
  mutate(Event = "Drop ≥10 g/L in ≤30 days")

# Combine and take most recent event per patient
hb_flagged_events <- bind_rows(drop_below_target, drop_10_in_1_month) %>%
  arrange(`Ur Number`, desc(CollectedDate)) %>%
  group_by(`Ur Number`) %>%
  slice_head(n = 1) %>%
  ungroup() %>%
  filter(CollectedDate >= Sys.Date() - 30) %>%   # was just getting too many hits with the synthetic stuff
  select(`Ur Number`, CollectedDate, HGB, prev_HGB, delta_HGB, delta_days, Event, dHb_over_dDays)

# Recalculate summary counts
n_drop_below_target <- hb_flagged_events %>%
  filter(Event == "Drop from ≥80 to <80 g/L") %>%
  n_distinct("Ur Number")

n_drop_10_in_1_month <- hb_flagged_events %>%
  filter(Event == "Drop ≥10 g/L in ≤30 days") %>%
  n_distinct("Ur Number")

# Output summary
cat("Patients who dropped from ≥80 to <80 g/L within 30 days: ", n_drop_below_target, "\n")
cat("Patients with ≥10 g/L HGB drop within 30 days: ", n_drop_10_in_1_month, "\n")

# Output final table
hb_flagged_events %>%
  arrange(dHb_over_dDays, `Ur Number`, CollectedDate) %>%
  kable(caption = "Most Recent Flagged Haemoglobin Event per Patient within 30 days", digits = 1) %>%
  kable_styling(full_width = FALSE)

```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width = 6, fig.height = 4)


#tinytex::install_tinytex() #LaTeX renderer required to generate PDFs

library(ggplot2)

#ptSubset<-coreData %>% filter(`Ur Number` == ptURN)
# Allow for reports for 
# - single pts
# - list of single pts (e.g. show time-series for pts URN a, b, c, d ?all in one file vs ?separate files)
# - aggregated pts (e.g. show / summarise pt results + URNS when Hb < 70)

#coreData <- read.csv("DUMMY_DAT.csv", na.strings=c(""," ","NA")) ## prepped earlier so muted this

# Every time this script is run, a "random pt" set will be generated - pt datasets will be variable ## EOS: why this approach and not just all ?
#randomData <- coreData; randomData[sample(nrow(randomData), 70), 'Ur.Number'] <- ptURN
#ptSubset <- subset(randomData, Ur.Number == ptURN)
# ,"<  10", ">1000" 
# 

coreData$HBSAB[coreData$HBSAB == "<  10"] <- "<10"
coreData$HBSAB[coreData$HBSAB >10] <- "10-1000"
coreData$HBSAB[coreData$HBSAB == ">1000"] <- ">1000"
coreData$HBSAB <- factor(coreData$HBSAB, levels=c("<10", "10-1000", ">1000"))

coreData$Collected <- as.POSIXct(coreData$Collected, format="%d/%m/%Y %H:%M")

#scatterplotTheme <- theme_minimal() +
#  theme(panel.grid.major = element_blank(),
#  panel.grid.minor = element_blank(),
#  axis.title.y = element_text(angle = 0, vjust = 0.5),
#  axis.title.x = element_text(vjust = -1)
#  )

```

# Transferrin Saturation

```{r TRFSAT, echo=FALSE, error=FALSE, message=FALSE, warning=FALSE, eval=FALSE}
# TRFSATS - overall Data
ggplot(coreData %>% 
  aes(x = CollectedDate, y = TRFSAT)) +
  geom_point(alpha = 0.25, size = 1.5, color = "grey40") +
  geom_smooth(method = "loess", span = 0.25, se = TRUE,
              color = "firebrick", fill = "firebrick", alpha = 0.2) +
  geom_line(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
            WeekStart > dateWindow[1], 
            WeekStart < dateWindow[2]), 
            aes(x = WeekStart, y = median_TRFSAT),
            inherit.aes = FALSE, color = "steelblue", linewidth = 1.2) +
  geom_point(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
              WeekStart > dateWindow[1], 
              WeekStart < dateWindow[2]),
              aes(x = WeekStart, y = median_TRFSAT),
              inherit.aes = FALSE, color = "steelblue", size = 2) +
  geom_hline(yintercept = thresholds$TRFSAT, color = "red", linetype = "dashed") +
  scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
  labs(
    title = "Transferrin Saturation",
    subtitle = "",
    x = "Date", y = "T-SATS %"
  ) +
  scatterplotTheme


# TRFSATS - Pt Subset
ggplot(coreData %>% filter( #keep dates within range of dateWindow dates
  CollectedDate > ptCollectedDates[1], 
  CollectedDate < ptCollectedDates[2]), 
  aes(x = CollectedDate, y = TRFSAT)) +
  geom_point(alpha = 0.25, size = 1.5, color = "grey65") +
  geom_smooth(method = "loess", span = 0.25, se = TRUE,
              color = "firebrick", fill = "firebrick", alpha = 0.1) +
  geom_line(data =ptSubset %>% filter( #keep dates within range of ptCollectedDates
            CollectedDate >= ptCollectedDates[1], # can likely expand this to contain multiple pts w/ group_by feature
            CollectedDate <= ptCollectedDates[2]),
            aes(x = CollectedDate, y =TRFSAT),
            inherit.aes = FALSE, color = "darkslateblue", linewidth = 1.2) +
 # geom_point(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
 #             WeekStart > dateWindow[1], 
 #             WeekStart < dateWindow[2]),
 #             aes(x = WeekStart, y = median_HGB),
 #             inherit.aes = FALSE, color = "steelblue", size = 2) +
  geom_hline(yintercept = thresholds$TRFSAT, color = "red", linetype = "dashed") +
  scale_x_date(date_breaks = "3 months", date_labels = "%b %Y") +
  labs(
    title = "Transferrin Saturation",
    subtitle = "",
    x = "Date", y = "T-SATS %"
  ) +
  scatterplotTheme
# TODO: ADD table listing pt values below graph



```

# Serum Potassium

```{r K, echo = FALSE, error = FALSE, message=FALSE, warning=FALSE, eval=FALSE}
ggplot(coreData %>% filter( #keep dates within range of dateWindow dates
  CollectedDate>dateWindow[1], 
  CollectedDate <dateWindow[2]), 
  aes(x = CollectedDate, y = K)) +
  geom_point(alpha = 0.25, size = 1.5, color = "grey40") +
  geom_smooth(method = "loess", span = 0.25, se = TRUE,
              color = "firebrick", fill = "firebrick", alpha = 0.2) +
  geom_line(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
            WeekStart > dateWindow[1], 
            WeekStart < dateWindow[2]), 
            aes(x = WeekStart, y = median_K),
            inherit.aes = FALSE, color = "steelblue", linewidth = 1.2) +
  geom_point(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
              WeekStart > dateWindow[1], 
              WeekStart < dateWindow[2]),
              aes(x = WeekStart, y = median_K),
              inherit.aes = FALSE, color = "steelblue", size = 2) +
  geom_hline(yintercept = thresholds$K, color = "red", linetype = "dashed") +
  scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
  labs(
    title = "K+ Levels Over Time",
    subtitle = "",
    x = "Date", y = "K"
  ) +
  scatterplotTheme

ggplot(coreData %>% filter( #keep dates within range of dateWindow dates
  CollectedDate > ptCollectedDates[1], 
  CollectedDate < ptCollectedDates[2]), 
  aes(x = CollectedDate, y = K)) +
  geom_point(alpha = 0.25, size = 1.5, color = "grey65") +
  geom_smooth(method = "loess", span = 0.25, se = TRUE,
              color = "firebrick", fill = "firebrick", alpha = 0.1) +
  geom_line(data =ptSubset %>% filter( #keep dates within range of ptCollectedDates
            CollectedDate >= ptCollectedDates[1], # can likely expand this to contain multiple pts w/ group_by feature
            CollectedDate <= ptCollectedDates[2]),
            aes(x = CollectedDate, y =K),
            inherit.aes = FALSE, color = "darkslateblue", linewidth = 1.2) +
 # geom_point(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
 #             WeekStart > dateWindow[1], 
 #             WeekStart < dateWindow[2]),
 #             aes(x = WeekStart, y = median_HGB),
 #             inherit.aes = FALSE, color = "steelblue", size = 2) +
  geom_hline(yintercept = thresholds$K, color = "red", linetype = "dashed") +
  scale_x_date(date_breaks = "3 months", date_labels = "%b %Y") +
  labs(
    title = " Individual Pt K Over Time",
    subtitle = "",
    x = "Date", y = "Potassium Levels"
  ) +
  scatterplotTheme

```

# Serum Parathyroid Hormone

```{r PTHR, echo = FALSE, error = FALSE, message=FALSE, warning=FALSE,eval=FALSE}
ggplot(coreData %>% filter( #keep dates within range of dateWindow dates
  CollectedDate>dateWindow[1], 
  CollectedDate <dateWindow[2]), 
  aes(x = CollectedDate, y = PTHR)) +
  geom_point(alpha = 0.25, size = 1.5, color = "grey40") +
  geom_smooth(method = "loess", span = 0.25, se = TRUE,
              color = "firebrick", fill = "firebrick", alpha = 0.2) +
  geom_line(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
            WeekStart > dateWindow[1], 
            WeekStart < dateWindow[2]), 
            aes(x = WeekStart, y = median_PTHR),
            inherit.aes = FALSE, color = "steelblue", linewidth = 1.2) +
  geom_point(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
              WeekStart > dateWindow[1], 
              WeekStart < dateWindow[2]),
              aes(x = WeekStart, y = median_PTHR),
              inherit.aes = FALSE, color = "steelblue", size = 2) +
  geom_hline(yintercept = thresholds$PTHR, color = "red", linetype = "dashed") +
  scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
  labs(
    title = "PTH Levels Over Time",
    subtitle = "",
    x = "Date", y = "PTH Levels"
  ) +
  scatterplotTheme

ggplot(coreData %>% filter( #keep dates within range of dateWindow dates
  CollectedDate > ptCollectedDates[1], 
  CollectedDate < ptCollectedDates[2]), 
  aes(x = CollectedDate, y = PTHR)) +
  geom_point(alpha = 0.25, size = 1.5, color = "grey65") +
  geom_smooth(method = "loess", span = 0.25, se = TRUE,
              color = "firebrick", fill = "firebrick", alpha = 0.1) +
  geom_line(data =ptSubset %>% filter( #keep dates within range of ptCollectedDates
            CollectedDate >= ptCollectedDates[1], # can likely expand this to contain multiple pts w/ group_by feature
            CollectedDate <= ptCollectedDates[2]),
            aes(x = CollectedDate, y =PTHR),
            inherit.aes = FALSE, color = "darkslateblue", linewidth = 1.2) +
 # geom_point(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
 #             WeekStart > dateWindow[1], 
 #             WeekStart < dateWindow[2]),
 #             aes(x = WeekStart, y = median_HGB),
 #             inherit.aes = FALSE, color = "steelblue", size = 2) +
  geom_hline(yintercept = thresholds$PTHR, color = "red", linetype = "dashed") +
  scale_x_date(date_breaks = "3 months", date_labels = "%b %Y") +
  labs(
    title = " Individual Pt PTH Over Time",
    subtitle = "",
    x = "Date", y = "Parathyroid Hormone Levels"
  ) +
  scatterplotTheme

```

# Serum Phosphate

```{r PHOS, echo = FALSE, error = FALSE, message=FALSE, warning=FALSE,eval=FALSE}
ggplot(coreData %>% filter( #keep dates within range of dateWindow dates
  CollectedDate>dateWindow[1], 
  CollectedDate <dateWindow[2]), 
  aes(x = CollectedDate, y = PHOS)) +
  geom_point(alpha = 0.25, size = 1.5, color = "grey40") +
  geom_smooth(method = "loess", span = 0.25, se = TRUE,
              color = "firebrick", fill = "firebrick", alpha = 0.2) +
  geom_line(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
            WeekStart > dateWindow[1], 
            WeekStart < dateWindow[2]), 
            aes(x = WeekStart, y = median_PHOS),
            inherit.aes = FALSE, color = "steelblue", linewidth = 1.2) +
  geom_point(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
              WeekStart > dateWindow[1], 
              WeekStart < dateWindow[2]),
              aes(x = WeekStart, y = median_PHOS),
              inherit.aes = FALSE, color = "steelblue", size = 2) +
  geom_hline(yintercept = thresholds$PHOS, color = "red", linetype = "dashed") +
  scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
  labs(
    title = "PHOS Levels Over Time",
    subtitle = "",
    x = "Date", y = "Phosphate"
  ) +
  scatterplotTheme

ggplot(coreData %>% filter( #keep dates within range of dateWindow dates
  CollectedDate > ptCollectedDates[1], 
  CollectedDate < ptCollectedDates[2]), 
  aes(x = CollectedDate, y = PHOS)) +
  geom_point(alpha = 0.25, size = 1.5, color = "grey65") +
  geom_smooth(method = "loess", span = 0.25, se = TRUE,
              color = "firebrick", fill = "firebrick", alpha = 0.1) +
  geom_line(data =ptSubset %>% filter( #keep dates within range of ptCollectedDates
            CollectedDate >= ptCollectedDates[1], # can likely expand this to contain multiple pts w/ group_by feature
            CollectedDate <= ptCollectedDates[2]),
            aes(x = CollectedDate, y =PHOS),
            inherit.aes = FALSE, color = "darkslateblue", linewidth = 1.2) +
 # geom_point(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
 #             WeekStart > dateWindow[1], 
 #             WeekStart < dateWindow[2]),
 #             aes(x = WeekStart, y = median_HGB),
 #             inherit.aes = FALSE, color = "steelblue", size = 2) +
  geom_hline(yintercept = thresholds$PHOS, color = "red", linetype = "dashed") +
  scale_x_date(date_breaks = "3 months", date_labels = "%b %Y") +
  labs(
    title = " Individual Pt PHOS Over Time",
    subtitle = "",
    x = "Date", y = "Phosphate Levels"
  ) +
  scatterplotTheme

```

# Serum Calcium

```{r CAL, echo = FALSE, error = FALSE, message=FALSE, warning=FALSE,eval=FALSE}
ggplot(coreData %>% filter( #keep dates within range of dateWindow dates
  CollectedDate>dateWindow[1], 
  CollectedDate <dateWindow[2]), 
  aes(x = CollectedDate, y = CAL)) +
  geom_point(alpha = 0.25, size = 1.5, color = "grey40") +
  geom_smooth(method = "loess", span = 0.25, se = TRUE,
              color = "firebrick", fill = "firebrick", alpha = 0.2) +
  geom_line(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
            WeekStart > dateWindow[1], 
            WeekStart < dateWindow[2]), 
            aes(x = WeekStart, y = median_CAL),
            inherit.aes = FALSE, color = "steelblue", linewidth = 1.2) +
  geom_point(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
              WeekStart > dateWindow[1], 
              WeekStart < dateWindow[2]),
              aes(x = WeekStart, y = median_CAL),
              inherit.aes = FALSE, color = "steelblue", size = 2) +
  geom_hline(yintercept = thresholds$CAL, color = "red", linetype = "dashed") +
  scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
  labs(
    title = "Calcium Levels Over Time",
    subtitle = "",
    x = "Date", y = "Calcium"
  ) +
  scatterplotTheme

ggplot(coreData %>% filter( #keep dates within range of dateWindow dates
  CollectedDate > ptCollectedDates[1], 
  CollectedDate < ptCollectedDates[2]), 
  aes(x = CollectedDate, y = CAL)) +
  geom_point(alpha = 0.25, size = 1.5, color = "grey65") +
  geom_smooth(method = "loess", span = 0.25, se = TRUE,
              color = "firebrick", fill = "firebrick", alpha = 0.1) +
  geom_line(data =ptSubset %>% filter( #keep dates within range of ptCollectedDates
            CollectedDate >= ptCollectedDates[1], # can likely expand this to contain multiple pts w/ group_by feature
            CollectedDate <= ptCollectedDates[2]),
            aes(x = CollectedDate, y =CAL),
            inherit.aes = FALSE, color = "darkslateblue", linewidth = 1.2) +
 # geom_point(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
 #             WeekStart > dateWindow[1], 
 #             WeekStart < dateWindow[2]),
 #             aes(x = WeekStart, y = median_HGB),
 #             inherit.aes = FALSE, color = "steelblue", size = 2) +
  geom_hline(yintercept = thresholds$CAL, color = "red", linetype = "dashed") +
  scale_x_date(date_breaks = "3 months", date_labels = "%b %Y") +
  labs(
    title = " Individual Pt calcium Over Time",
    subtitle = "",
    x = "Date", y = "Calcium Levels"
  ) +
  scatterplotTheme

```

# Serum Albumin

```{r ALB, echo = FALSE, error = FALSE, message=FALSE, warning=FALSE,eval=FALSE}
ggplot(coreData %>% filter( #keep dates within range of dateWindow dates
  CollectedDate>dateWindow[1], 
  CollectedDate <dateWindow[2]), 
  aes(x = CollectedDate, y = ALB)) +
  geom_point(alpha = 0.25, size = 1.5, color = "grey40") +
  geom_smooth(method = "loess", span = 0.25, se = TRUE,
              color = "firebrick", fill = "firebrick", alpha = 0.2) +
  geom_line(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
            WeekStart > dateWindow[1], 
            WeekStart < dateWindow[2]), 
            aes(x = WeekStart, y = median_ALB),
            inherit.aes = FALSE, color = "steelblue", linewidth = 1.2) +
  geom_point(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
              WeekStart > dateWindow[1], 
              WeekStart < dateWindow[2]),
              aes(x = WeekStart, y = median_ALB),
              inherit.aes = FALSE, color = "steelblue", size = 2) +
  geom_hline(yintercept = thresholds$ALB, color = "red", linetype = "dashed") +
  scale_x_date(date_breaks = "1 month", date_labels = "%b %Y") +
  labs(
    title = "Albumin levels Over Time",
    subtitle = "",
    x = "Date", y = "Albumin"
  ) +
  scatterplotTheme

ggplot(coreData %>% filter( #keep dates within range of dateWindow dates
  CollectedDate > ptCollectedDates[1], 
  CollectedDate < ptCollectedDates[2]), 
  aes(x = CollectedDate, y = ALB)) +
  geom_point(alpha = 0.25, size = 1.5, color = "grey65") +
  geom_smooth(method = "loess", span = 0.25, se = TRUE,
              color = "firebrick", fill = "firebrick", alpha = 0.1) +
  geom_line(data =ptSubset %>% filter( #keep dates within range of ptCollectedDates
            CollectedDate >= ptCollectedDates[1], # can likely expand this to contain multiple pts w/ group_by feature
            CollectedDate <= ptCollectedDates[2]),
            aes(x = CollectedDate, y =ALB),
            inherit.aes = FALSE, color = "darkslateblue", linewidth = 1.2) +
 # geom_point(data = weekly_summary %>% filter( #keep dates within range of dateWindow dates
 #             WeekStart > dateWindow[1], 
 #             WeekStart < dateWindow[2]),
 #             aes(x = WeekStart, y = median_HGB),
 #             inherit.aes = FALSE, color = "steelblue", size = 2) +
  geom_hline(yintercept = thresholds$ALB, color = "red", linetype = "dashed") +
  scale_x_date(date_breaks = "3 months", date_labels = "%b %Y") +
  labs(
    title = " Individual Pt Albumin Over Time",
    subtitle = "",
    x = "Date", y = "Albumin levels"
  ) +
  scatterplotTheme

```

# Hepatitis B Serum Antibodies

```{r HBSAB, echo = FALSE, error = FALSE, message=FALSE, warning=FALSE,eval=FALSE}
# TODO: Handle <10 and > 1000 values
ggplot(data=na.omit(coreData), 
       aes(x=as.Date(Collected, format="%d/%m/%Y %H:%M"), y=HBSAB, group=1)) +
  geom_point() +
  #ylim(-2, 60) +
#  geom_hline(yintercept = 19, color = "red") + 
 # geom_hline(yintercept = 26, color = "red") +
  scale_x_date(date_breaks = "1 month", date_labels =  "%b %Y") +
 # geom_smooth(method=stats::loess, se=F, 
  #                    method.args=list(degree=0,span=10)) +
  xlab("Sample Collection Date (Month Year)") +
  ggtitle("Serum HBSAB Levels - Normal >10") +
  scatterplotTheme
  #scale_y_continuous(limits = c(10,35), breaks = seq(0,35,5))

```
